makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached
inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
size <- 10                                      # create data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
M1 <- makeCacheMatrix()                         # create caching data structure
M1
environment(M1)
M1$set(mydata)                                  # place data into structure
M1$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(M1)                          # calculate the inverse
imat_cached <- cacheSolve(M1)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                    # verify inverse and cached inversed are the same
test <- mydata %*% imat                         # verify matrix %*% inverse = identity matrix
View(test)
## R Programming - April 2014
## Programming Assignment 2 - Caching the Inverse of a Matrix
##
# In this example we introduce the <<- operator which can be used to assign a
# value to an object in an environment that is different from the current
# environment.
# Below are two functions that are used to create a special object
# that stores a matrix and cache's its inverse.
#
# The first function, makeVector creates a special "vector", which is really a
# list containing a function to:
# - set the matrix
# - get matrix
# - set matrix inverse
# - get matrix inverse
makeCacheMatrix <- function(x = matrix()) {
invCached <- matrix(data = NA, nrow = 1,                # set cached inverse matrix to "empty"
ncol = 1, byrow = FALSE,
dimnames = NULL)
set <- function(y) {                                    # method to store data matrix
x <<- y
invCached <<- matrix(NA, 1, 1, FALSE, NULL)     # reset cached inverse to "empty"
}
get <- function() x                                     # method to retrieve data matrix
setInverse <- function(inverse) invCached <<- inverse   # method to store mean
getInverse <- function() invCached                      # method to retrieve mean
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
# The second function calculates the inverse of the object. It checks to see if the inverse
# has already been calculated. Ff not, it calculates the inverse and stores it
# in the object.  Returns a matrix that is the inverse of 'x'
cacheSolve <- function(x, ...) {
inverse <- x$getInverse()               # retrieve cached inverse
if(!is.na(inverse[1,1])) {              # if not empty, return cached inverse
message("getting cached inverse matrix")
return(inverse)                 # use invisible(inverse) to suppress print()
}
data <- x$get()                         # otherwise get cached data
inverse <- solve(data, ...)             # calculate the inverse
x$setInverse(inverse)                   # save the inverse into cache
inverse
}
# Now use these functions to generate an inverse matrix and cache it. Verify that
# the calculated and cached inverses are identical Verify that the matrix
# multiplied by its inverse is equal to the identity matrix
size <- 10                                       # create test data (square matrix)
mydata <- matrix(rnorm(size*size), size, size)
mat <- makeCacheMatrix()                         # create caching data structure
mat
mat$set(mydata)                                  # place data into structure
mat$getInverse()                                 # get inverse (empty at this point)
imat <- cacheSolve(mat)                          # calculate the inverse
imat_cached <- cacheSolve(mat)                   # caculate the inverse again (retrieved cached value)
identical(imat, imat_cached)                     # verify inverse and cached inversed are the same
test <- mydata %*% imat                          # verify matrix %*% inverse = identity matrix
View(test)
setwd("~/CourseraHW/Rprogramming/RprogrammingAssignment3")
state<- "TX"
outcome <- "heart failure"
j <- "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure"
alldata <- read.csv("outcome-of-care-measures.csv",     # Data import problem resolved
colClasses = "character",           # by coercing to "character"
stringsAsFactors=FALSE)             # (prevent creation of levels)
View(alldata)
alldata[1,11]
class(alldata[1,11])
statedata <- alldata[alldata$State == state,]           # subset all rows for selected state
str(statedata)
class(statedata)
statedata[,j] <- suppressWarnings(as.numeric(statedata[,j]))
str(statedata)
View(statedata)
statedata[,j] <- suppressWarnings(as.numeric(statedata[,j]))
View(statedata)
statedata[2,11]
class(statedata[2,11])
statedata <- alldata[alldata$State == state,]           # subset all rows for selected state
statedata[,j] <- as.numeric(statedata[,j])
View(statedata)
statedata[2,11]
state<- "TX"
outcome <- "heart failure"
j <- "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure"
alldata <- read.csv("outcome-of-care-measures.csv",     # Data import problem resolved
colClasses = "character")           # by coercing to "character"
#   stringsAsFactors=FALSE)             # (prevent creation of levels)
statedata <- alldata[alldata$State == state,]           # subset all rows for selected state
# Convert to numeric, non-numeric data coerced to NAs
statedata[,j] <- suppressWarnings(as.numeric(statedata[,j]))
class(statedata[2,11])
class(statedata[2,12])
datacol <- as.numeric(subset(statedata)[,j])                             # extract mortality rate column
namecol <- as.character(subset(statedata)[,"Hospital.Name"])    # extract hospital name column
subDF <- cbind(namecol,datacol)                                # create df with just 2 columns
subDF[,2] <- as.numeric(subDF[,2])
class(subDF)
summary(subDF)
cleanDF <- na.omit(subDF)
View(cleanDF)
class(cleanDF[1,2])
cleanDF[1,2]
XcleanDF[, 2] <- as.numeric(cleanDF[, 2])
cleanDF[, 2] <- as.numeric(cleanDF[, 2])
XcleanDF <- as.numeric(cleanDF[, 2])
cleanDF[, 2] <- as.numeric(cleanDF[, 2])
namecol <- as.character(subset(statedata)[,"Hospital.Name"],stringsAsFactors=FALSE)    # extract hospital name column
datacol <- as.character(subset(statedata)[,j], stringsAsFactors=FALSE )
namecol <- as.character(subset(statedata)[,"Hospital.Name"],stringsAsFactors=FALSE)    # extract hospital name column
subDF <- cbind(namecol,datacol, stringsAsFactors=FALSE)                                # create df with just 2 columns
View(subDF)
subDF[,2] <- as.numeric(subDF[,2])
View(subDF)
class(subDF[1,2])
class(subDF)
x<- as.numeric(subDF)
n1 <- as.numeric(datacol[1])
n1
class(n1)
datacol <- as.numeric(subset(statedata)[,j])                             # extract mortality rate column
foo <- cbind.data.frame(namecol,datacol)
state<- "TX"
outcome <- "heart failure"
j <- "Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure"
alldata <- read.csv("outcome-of-care-measures.csv",     # Data import problem resolved
colClasses = "character")           # by coercing to "character"
#   stringsAsFactors=FALSE)             # (prevent creation of levels)
statedata <- alldata[alldata$State == state,]           # subset all rows for selected state
# Convert to numeric, non-numeric data coerced to NAs
statedata[,j] <- suppressWarnings(as.numeric(statedata[,j]))
statedata[,j] <- as.numeric(statedata[,j])
# Condense data to just hospital and mortality rate
datacol <- as.numeric(subset(statedata)[,j])                             # extract mortality rate column
#datacol <- as.character(subset(statedata)[,j], stringsAsFactors=FALSE )
namecol <- as.character(subset(statedata)[,"Hospital.Name"],stringsAsFactors=FALSE)    # extract hospital name column
#subDF <- cbind(namecol,datacol)                                # create df with just 2 columns
subDF <- cbind.data.frame(namecol,datacol)
str(subDF)
class(subDF[1,2])
View(subDF)
cleanDF <- na.omit(subDF)
View(cleanDF)
class(cleanDF[1,2])
sortedDF <- cleanDF[ order(cleanDF[,2], cleanDF[,1]), ]
View(sortedDF)
source("best.R")
best(state = "TX", outcome = "heart attack")
best(state = "TX", outcome = "heart failure")
best(state = "MD", outcome = "heart attack")
best(state = "MD", outcome = "pneumonia")
best("BB", "heart attack")
best("NY", "hert attack")
best("OR", "heart attack")
best("OR", "pneumonia")
best(state = "OR", outcome = "heart failure")
setwd("~/CourseraHW/RprogrammingAssignment3")
source("best.R")
best(state = "TX", outcome = "heart attack")
best(state = "TX", outcome = "heart failure")
best(state = "MD", outcome = "heart attack")
best(state = "MD", outcome = "pneumonia")
best("BB", "heart attack")
best("NY", "hert attack")
